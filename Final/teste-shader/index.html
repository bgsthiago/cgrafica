<html>
  <head>
    <title>Textura (Three.js)</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  </head>
  <body style="margin: 0px;">
    <div id="ThreeJS" style="position: absolute; left:0px; top:0px"></div>
    <script src="https://stemkoski.github.io/Three.js/js/Three.js"></script>
    <script>
          // variaveis globais Note que sempre tem camera, scene e renderer
          var scene, camera, renderer, controls, stats;
          var clock = new THREE.Clock();
          // E sempre tem Mesh
          var mesh;
          var container = document.getElementById('ThreeJS');
          init();
          animate(); //onde a magica acontece

          //FUNÇÕES
          function init()
          {
            // SCENE
            scene = new THREE.Scene();

            // CAMERA
            var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
            var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
            camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
            scene.add(camera);
            camera.position.set(0,150,400);
            camera.lookAt(scene.position);

            // RENDERER
            renderer = new THREE.WebGLRenderer( {antialias:true} );
            renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
            //var container = document.getElementById('ThreeJS');
            container.appendChild( renderer.domElement );

            // LIGHT
            var light = new THREE.DirectionalLight(0xffffff);
            var amblight = new THREE.AmbientLight(0x404040);
            light.position.set(10,250, 200);
            scene.add(light);
            scene.add(amblight);

            ////////////
            // CUSTOM //
            ////////////
            /*var tex = THREE.ImageUtils.loadTexture('texture.png');
            tex.minFilter = THREE.LinearFilter;
            var geometry = new THREE.PlaneGeometry( 50,50 );
            var material = new THREE.MeshBasicMaterial( {
              map: tex,
              side: THREE.DoubleSide,
              transparent: true
              } );
            material.li*/

            var geometry = new THREE.PlaneGeometry( 50,50 );
            var creatureImage = THREE.ImageUtils.loadTexture('texture.png');
            creatureImage.magFilter = THREE.NearestFilter;//mantem pixelado
            var material = new THREE.ShaderMaterial({//allows us to specify our custom vertex and fragment shaders.
                uniforms: THREE.UniformsUtils.merge([
                    THREE.UniformsLib['lights'],
                    {
                        color: {type: 'f', value: 0.0},
                        evilCreature: {type: 't', value: null}
                    }
                ]),
                vertexShader: document.getElementById( 'vertShader' ).textContent,
                fragmentShader: document.getElementById( 'fragShader').textContent,
                transparent: true,
                lights: true
            });
            material.uniforms.evilCreature.value = creatureImage;
            mesh = new THREE.Mesh( geometry, material );
            mesh.position.set(0,0,0);
            scene.add(mesh);

            // Create light
            var light = new THREE.PointLight(0xffffff, 1.0);
            // We want it to be very close to our character
            light.position.set(0.0,0.0,0.1);
            scene.add(light);
          }

          function animate()
          {
            var c = 0.5+0.5*Math.cos(
                    new Date().getTime()/1000.0 * Math.PI);
            mesh.material.uniforms.color.value = c;
            requestAnimationFrame( animate );
            render();
            update();
          }

          function update()
          {
            if ( keyboard.pressed("z") )
            {
              // do something
            }

            controls.update();
            stats.update();
          }

          function render()
          {
            renderer.render( scene, camera );
          }

    </script>
    <script id="vertShader" type="shader">
      varying vec2 vUv;
      varying vec3 vecPos;
      varying vec3 vecNormal;

      void main() {
          vUv = uv;
          // Since the light is on world coordinates,
          // I'll need the vertex position in world coords too
          // (or I could transform the light position to view
          // coordinates, but that would be more expensive)
          vecPos = (modelMatrix * vec4(position, 1.0 )).xyz;
          // That's NOT exacly how you should transform your
          // normals but this will work fine, since my model
          // matrix is pretty basic
          vecNormal = (modelMatrix * vec4(normal, 0.0)).xyz;
          gl_Position = projectionMatrix * viewMatrix *
                        vec4(vecPos, 1.0);
      }
    </script>
    <script id="fragShader" type="shader">
      precision highp float;
      varying vec2 vUv; //varying uv = the texture coord
      varying vec3 vecPos;
      varying vec3 vecNormal;
      uniform float color;
      // Name it whatever it was named in the uniforms object
      uniform sampler2D evilCreature;

      uniform vec3 pointLightColor[MAX_POINT_LIGHTS];
      uniform vec3 pointLightPosition[MAX_POINT_LIGHTS];
      uniform float pointLightDistance[MAX_POINT_LIGHTS];
      void main(void) {
        // Pretty basic lambertian lighting...
        vec4 addedLights = vec4(0.0,0.0,0.0, 1.0);
        for(int l = 0; l < MAX_POINT_LIGHTS; l++) {
            vec3 lightDirection = normalize(vecPos
                                  -pointLightPosition[l]);
            addedLights.rgb += clamp(dot(-lightDirection,
                                     vecNormal), 0.0, 1.0)
                               * pointLightColor[l];
        }
        gl_FragColor = texture2D(evilCreature, vUv)
                           * addedLights;
      }
    </script>
  </body>
</html>
